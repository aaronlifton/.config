-- iglob treesitter picker
local M = {}

-- Helpers
local H = {}

H.is_executable = function(tool)
  if tool == "fallback" then return true end
  return vim.fn.executable(tool) == 1
end
H.is_array_of = function(x, ref_type)
  if not vim.tbl_islist(x) then return false end
  for i = 1, #x do
    if type(x[i]) ~= ref_type then return false end
  end
  return true
end
H.get_config = function(config)
  return vim.tbl_deep_extend("force", MiniPick.config, vim.b.minipick_config or {}, config or {})
end
H.full_path = function(path)
  return (vim.fn.fnamemodify(path, ":p"):gsub("(.)/$", "%1"))
end
local function parse_query(raw)
  local search, iglob = raw:match("^(.-)%s+%-%-%s+(.*)$")
  if not search then return vim.trim(raw), {} end

  local patterns = {}
  for _, part in ipairs(vim.split(vim.trim(iglob), "%s+", { trimempty = true })) do
    patterns[#patterns + 1] = part
  end

  return vim.trim(search), patterns
end

local function map_gsub(items, pattern, replacement)
  return vim.tbl_map(function(item)
    item, _ = string.gsub(item, pattern, replacement)
    return item
  end, items)
end

local function split_grep_item(item)
  if type(item) ~= "string" then return nil end
  local parts = vim.split(item, "\0", { plain = true })
  if #parts < 4 then return nil end
  return {
    path = parts[1],
    lnum = tonumber(parts[2]),
    col = tonumber(parts[3]),
    text = parts[4],
  }
end

-- Truncate path to max_width, preserving filename
-- Modes: "head" (truncate start), "middle" (truncate middle), "smart" (keep first + last dirs)
---@param path string
---@param max_width number
---@param mode? "head"|"middle"|"smart"
---@return string
local function truncate_path(path, max_width, mode)
  if #path <= max_width then return path end
  mode = mode or "smart"

  local dir, filename = path:match("^(.*)/([^/]+)$")
  if not dir then return path:sub(1, max_width - 1) .. "…" end

  -- Reserve space for filename + separator + ellipsis
  local available = max_width - #filename - 2 -- "…/"
  if available <= 0 then
    -- Filename alone is too long, truncate it
    return "…" .. filename:sub(-(max_width - 1))
  end

  if mode == "head" then
    -- Truncate from start: …/rest/of/path/file.lua
    return "…" .. dir:sub(-available) .. "/" .. filename
  elseif mode == "middle" then
    -- Truncate from middle: start/…/end/file.lua
    local half = math.floor(available / 2)
    local left = dir:sub(1, half)
    local right = dir:sub(-(available - half - 1))
    return left .. "…" .. right .. "/" .. filename
  else -- "smart"
    -- Keep first directory and filename: first/…/file.lua
    local first_dir = dir:match("^([^/]+)")
    if first_dir and #first_dir + 3 < available then
      local rest_available = available - #first_dir - 2 -- "/…"
      local rest = dir:sub(#first_dir + 2) -- skip "first_dir/"
      if #rest > rest_available then rest = "…" .. rest:sub(-rest_available + 1) end
      return first_dir .. "/" .. rest .. "/" .. filename
    else
      -- Fall back to head truncation
      return "…" .. dir:sub(-available) .. "/" .. filename
    end
  end
end

local function find_last(haystack, needle)
  if needle == "" then return nil end
  local last, init = nil, 1
  while true do
    local s = string.find(haystack, needle, init, true)
    if not s then break end
    last, init = s, s + 1
  end
  return last
end

local function get_ts_cache()
  if H._ts_cache ~= nil then return H._ts_cache end
  H._ts_cache = {
    ns = vim.api.nvim_create_namespace("minipick-iglob-ts"),
    bufs = {},
    queries = {},
  }
  return H._ts_cache
end

local function ensure_scratch_buf(lang)
  local cache = get_ts_cache()
  if cache.bufs[lang] and vim.api.nvim_buf_is_valid(cache.bufs[lang]) then return cache.bufs[lang] end
  local buf = vim.api.nvim_create_buf(false, true)
  vim.bo[buf].bufhidden = "wipe"
  cache.bufs[lang] = buf
  return buf
end

local function get_highlight_query(lang)
  local cache = get_ts_cache()
  if cache.queries[lang] ~= nil then return cache.queries[lang] end
  local query = vim.treesitter.query.get(lang, "highlights")
  cache.queries[lang] = query
  return query
end

local function highlight_line_ts(buf_id, row, text, lang, col_offset)
  local cache = get_ts_cache()
  local scratch = ensure_scratch_buf(lang)
  vim.api.nvim_buf_set_lines(scratch, 0, -1, false, { text })

  local ok_parser, parser = pcall(vim.treesitter.get_parser, scratch, lang, { error = false })
  if not ok_parser or not parser then return end

  local query = get_highlight_query(lang)
  if not query then return end

  local tree = parser:parse()[1]
  if not tree then return end

  local root = tree:root()
  local ext_opts = { hl_mode = "combine", priority = 150 }
  for id, node in query:iter_captures(root, scratch, 0, 1) do
    local capture = query.captures[id]
    local srow, scol, erow, ecol = node:range()
    if srow == 0 and erow == 0 and ecol > scol then
      ext_opts.hl_group = "@" .. capture
      ext_opts.end_row = row
      ext_opts.end_col = col_offset + ecol
      vim.api.nvim_buf_set_extmark(buf_id, cache.ns, row, col_offset + scol, ext_opts)
    end
  end
end

H.default_show_with_icons = function(buf_id, items, query)
  local sep = string.char(31)
  local sep_pattern = vim.pesc(sep)
  items = map_gsub(items, "%z", sep)
  items = require("mini.align").align_strings(items, {
    justify_side = { "left", "right", "right" },
    merge_delimiter = { "", " ", "", " ", "" },
    split_pattern = sep_pattern,
  })
  items = map_gsub(items, sep, "\0")
  MiniPick.default_show(buf_id, items, query, { show_icons = true })
end

-- Configuration:
--   vim.g.minipick_ts_highlight = true/false (default: true)
--   vim.g.minipick_max_ts_items = number (default: 200)
--   vim.g.minipick_path_max_width = number (default: nil, no truncation)
--   vim.g.minipick_path_truncate_mode = "head"|"middle"|"smart" (default: "smart")
H.grep_ts_show = function(buf_id, items, query, show_opts)
  show_opts = show_opts or {}
  local ts_highlight_override = show_opts.ts_highlight
  local path_max_width = show_opts.path_max_width or vim.g.minipick_path_max_width
  local path_truncate_mode = show_opts.path_truncate_mode or vim.g.minipick_path_truncate_mode or "smart"

  -- Apply path truncation if configured
  local display_items = items
  if path_max_width and path_max_width > 0 then
    display_items = vim.tbl_map(function(item)
      local parts = vim.split(item, "\0", { plain = true })
      if #parts >= 1 then
        parts[1] = truncate_path(parts[1], path_max_width, path_truncate_mode)
        return table.concat(parts, "\0")
      end
      return item
    end, items)
  end

  local sep = string.char(31)
  local sep_pattern = vim.pesc(sep)
  local aligned_items = map_gsub(display_items, "%z", sep)
  aligned_items = require("mini.align").align_strings(aligned_items, {
    justify_side = { "left", "right", "right" },
    merge_delimiter = { "", " ", "", " ", "" },
    split_pattern = sep_pattern,
  })
  aligned_items = map_gsub(aligned_items, sep, "│")

  local tab_spaces = string.rep(" ", vim.o.tabstop)
  local aligned_lines = vim.tbl_map(function(l)
    return l:gsub("%z", "│"):gsub("[\r\n]", " "):gsub("\t", tab_spaces)
  end, aligned_items)

  MiniPick.default_show(buf_id, aligned_items, query, { show_icons = true })

  -- Check if TS highlighting is enabled (override > global > default true)
  local ts_enabled = ts_highlight_override
  if ts_enabled == nil then ts_enabled = vim.g.minipick_ts_highlight end
  if ts_enabled == nil then ts_enabled = true end
  if not ts_enabled then return end

  local cache = get_ts_cache()
  vim.api.nvim_buf_clear_namespace(buf_id, cache.ns, 0, -1)
  local max_ts_items = vim.g.minipick_max_ts_items or 200
  if #items > max_ts_items then return end

  local lines = vim.api.nvim_buf_get_lines(buf_id, 0, -1, false)
  for i, item in ipairs(items) do
    local parsed = split_grep_item(item)
    if parsed and parsed.text then
      local ft = vim.filetype.match({ filename = parsed.path })
      if ft and ft ~= "" then
        local ok_lang, lang = pcall(vim.treesitter.language.get_lang, ft)
        lang = ok_lang and lang or ft
        local line = lines[i] or ""
        local aligned_line = aligned_lines[i] or ""
        local prefix_len = #line - #aligned_line
        local text_start = find_last(aligned_line, parsed.text) or (#aligned_line - #parsed.text + 1)
        if text_start < 1 then text_start = 1 end
        local col_offset = prefix_len + text_start - 1
        highlight_line_ts(buf_id, i - 1, parsed.text, lang, col_offset)
      end
    end
  end
end

-- Flag definitions for rg
H.rg_flags = {
  glob_case_insensitive = "--glob-case-insensitive",
  context = "--context 2",
  max_count = "--max-count 1",
  max_depth = "--max-depth 3",
  pcre2 = "--pcre2",
  dotall = "-U", -- dotall (?s:.) ; regular (?-s:.)
  sort_path = "--sort path",
  type_lua = "-t lua",
  type_ruby = "-t ruby",
  type_conf = "--type-add 'conf:*.{toml,yaml,yml,ini,json}' -t conf",
  type_web = "--type-add 'web:*.{js,ts,tsx,css,scss,html,vue,svelte}' -t web",
}

-- Predefined iglob patterns
H.iglob_patterns = {
  js_no_tests = "*.{js,ts,tsx} !*{test,spec}*",
  js_tests = "*.{js,ts,tsx} **test**",
  tests = "**{test,spec}**",
  no_tests = "!**{test,spec}** !spec/**/* !**/test*/** !__tests__",
  js_ts = "*.{js,ts,tsx}",
  no_bundle = "!**{umd,cjs,esm}**",
}

function H.grep_get_command(pattern, globs, flags)
  local res = {
    "rg",
    "--column",
    "--line-number",
    "--no-heading",
    "--field-match-separator",
    "\\x00",
    "--color=never",
  }
  if flags then
    if flags.no_ignore then table.insert(res, "--no-ignore") end
    if flags.hidden then table.insert(res, "--hidden") end
    -- Add extra flags
    if flags.extra then
      for flag_key, enabled in pairs(flags.extra) do
        if enabled and H.rg_flags[flag_key] then
          for _, part in ipairs(vim.split(H.rg_flags[flag_key], "%s+", { trimempty = true })) do
            table.insert(res, part)
          end
        end
      end
    end
  end
  for _, g in ipairs(globs) do
    table.insert(res, "--iglob")
    -- NOTE: no `*` as default is important to not "override" ignoring files
    table.insert(res, g)
  end
  local case = vim.o.ignorecase and (vim.o.smartcase and "smart-case" or "ignore-case") or "case-sensitive"
  vim.list_extend(res, { "--" .. case, "--", pattern })
  return res
end

local function create_iglob_picker(MiniPick)
  return function(local_opts, opts)
    local function igrep_live(local_opts, opts)
      local_opts = vim.tbl_extend("force", { tool = "rg", globs = {}, flags = {} }, local_opts or {})
      local tool = local_opts.tool -- or H.grep_get_tool()
      if tool == "fallback" or not H.is_executable(tool) then
        H.error("`grep_live` needs non-fallback executable tool.")
      end

      local globs = H.is_array_of(local_opts.globs, "string") and local_opts.globs or {}
      local flags = {
        no_ignore = local_opts.flags.no_ignore == true,
        hidden = local_opts.flags.hidden == true,
        extra = local_opts.flags.extra or {},
      }
      local formatted_name
      if opts.source.name then formatted_name = opts.source.name and (opts.source.name):format(" %s ") or nil end

      -- Show options (can be set via local_opts)
      local show_opts = {
        ts_highlight = local_opts.ts_highlight, -- nil = use global, false = disabled, true = enabled
        path_max_width = local_opts.path_max_width, -- nil = use global or no truncation
        path_truncate_mode = local_opts.path_truncate_mode, -- "head", "middle", "smart" (default)
      }

      local function build_name_suffix()
        local parts = {}
        if #globs > 0 then parts[#parts + 1] = table.concat(globs, ", ") end
        local flag_parts = {}
        if flags.hidden then flag_parts[#flag_parts + 1] = "--hidden" end
        if flags.no_ignore then flag_parts[#flag_parts + 1] = "--no-ignore" end
        for key, enabled in pairs(flags.extra or {}) do
          if enabled then flag_parts[#flag_parts + 1] = key end
        end
        if show_opts.ts_highlight == false then flag_parts[#flag_parts + 1] = "no-ts" end
        if show_opts.path_max_width then flag_parts[#flag_parts + 1] = "path:" .. show_opts.path_max_width end
        if #flag_parts > 0 then parts[#parts + 1] = table.concat(flag_parts, ", ") end
        return #parts == 0 and "" or (" | " .. table.concat(parts, " | "))
      end

      local function build_name()
        local name_suffix = build_name_suffix()
        if formatted_name then return string.format("Grep live (%s%s) | %s", tool, name_suffix, formatted_name) end
        return string.format("Grep live (%s%s)", tool, name_suffix)
      end

      local function get_show_func()
        return function(buf_id, items, query)
          H.grep_ts_show(buf_id, items, query, show_opts)
        end
      end

      local name = build_name()
      local default_source = {
        name = name,
        show = get_show_func(),
        choose_marked = require("util.minipick_registry.trouble").trouble_choose_marked,
      }

      opts = vim.tbl_deep_extend("force", { source = default_source }, opts or {})
      opts.source.name = default_source.name

      local cwd = H.full_path(opts.source.cwd or vim.fn.getcwd())
      local set_items_opts, spawn_opts = { do_match = false, querytick = MiniPick.get_querytick() }, { cwd = cwd }
      local process
      local match = function(_, _, query)
        ---@diagnostic disable-next-line: undefined-field
        pcall(vim.loop.process_kill, process)

        local querytick = MiniPick.get_querytick()
        if querytick == set_items_opts.querytick then return end
        if #query == 0 then return MiniPick.set_picker_items({}, set_items_opts) end

        set_items_opts.querytick = querytick

        local full_query = table.concat(query)
        local search_pattern, iglob_patterns = parse_query(full_query)

        if search_pattern == "" then return MiniPick.set_picker_items({}, set_items_opts) end

        local all_globs = vim.list_extend(vim.list_extend({}, iglob_patterns), globs)

        local command = H.grep_get_command(search_pattern, all_globs, flags)

        process = MiniPick.set_picker_items_from_cli(command, {
          set_items_opts = set_items_opts,
          spawn_opts = spawn_opts,
        })
      end

      local add_glob = function()
        local ok, glob = pcall(vim.fn.input, "iglob pattern: ")
        if ok then table.insert(globs, glob) end
        MiniPick.set_picker_opts({ source = { name = build_name() } })
        MiniPick.set_picker_query(MiniPick.get_picker_query())
      end

      local remove_glob = function()
        if #globs > 0 then
          table.remove(globs)
          MiniPick.set_picker_opts({ source = { name = build_name() } })
          MiniPick.set_picker_query(MiniPick.get_picker_query())
        end
      end

      local toggle_no_ignore = function()
        flags.no_ignore = not flags.no_ignore
        MiniPick.set_picker_opts({ source = { name = build_name() } })
        MiniPick.set_picker_query(MiniPick.get_picker_query())
      end

      local toggle_hidden = function()
        flags.hidden = not flags.hidden
        MiniPick.set_picker_opts({ source = { name = build_name() } })
        MiniPick.set_picker_query(MiniPick.get_picker_query())
      end

      local function toggle_extra_flag(flag_key)
        return function()
          flags.extra[flag_key] = not flags.extra[flag_key]
          MiniPick.set_picker_opts({ source = { name = build_name() } })
          MiniPick.set_picker_query(MiniPick.get_picker_query())
        end
      end

      local function toggle_dotall()
        local dotall_pattern = "(?s:.)"
        flags.extra.dotall = not flags.extra.dotall
        local query = MiniPick.get_picker_query()
        local query_str = table.concat(query)

        if flags.extra.dotall then
          -- Add (?s:.) after current query
          if not query_str:find(vim.pesc(dotall_pattern), 1, true) then query_str = query_str .. dotall_pattern end
        else
          -- Remove (?s:.) from query
          query_str = query_str:gsub(vim.pesc(dotall_pattern), "")
        end

        MiniPick.set_picker_opts({ source = { name = build_name() } })
        MiniPick.set_picker_query(vim.split(query_str, ""))
      end

      local function toggle_ts_highlight()
        -- Cycle: nil (use global) -> false (disabled) -> nil
        if show_opts.ts_highlight == nil then
          show_opts.ts_highlight = false
        else
          show_opts.ts_highlight = nil
        end
        MiniPick.set_picker_opts({ source = { name = build_name(), show = get_show_func() } })
        MiniPick.set_picker_query(MiniPick.get_picker_query())
      end

      local function toggle_path_width()
        -- Cycle: nil -> 60 -> 40 -> 80 -> nil
        local widths = { nil, 60, 40, 80 }
        local current_idx = 1
        for i, w in ipairs(widths) do
          if show_opts.path_max_width == w then
            current_idx = i
            break
          end
        end
        show_opts.path_max_width = widths[(current_idx % #widths) + 1]
        MiniPick.set_picker_opts({ source = { name = build_name(), show = get_show_func() } })
        MiniPick.set_picker_query(MiniPick.get_picker_query())
      end

      local function toggle_iglob_pattern(pattern_key)
        return function()
          local pattern = H.iglob_patterns[pattern_key]
          if not pattern then return end
          -- Check if pattern parts are already in globs
          local pattern_parts = vim.split(pattern, "%s+", { trimempty = true })
          local all_present = true
          for _, part in ipairs(pattern_parts) do
            local found = false
            for _, g in ipairs(globs) do
              if g == part then
                found = true
                break
              end
            end
            if not found then
              all_present = false
              break
            end
          end
          if all_present then
            -- Remove all pattern parts
            for _, part in ipairs(pattern_parts) do
              for i = #globs, 1, -1 do
                if globs[i] == part then
                  table.remove(globs, i)
                  break
                end
              end
            end
          else
            -- Add missing pattern parts
            for _, part in ipairs(pattern_parts) do
              local found = false
              for _, g in ipairs(globs) do
                if g == part then
                  found = true
                  break
                end
              end
              if not found then table.insert(globs, part) end
            end
          end
          MiniPick.set_picker_opts({ source = { name = build_name() } })
          MiniPick.set_picker_query(MiniPick.get_picker_query())
        end
      end

      -- Mnemonics (from fzf-extended.lua):
      --   alt-j: js/ts (non-tests)
      --   alt-o: only js/ts tests
      --   alt-t: tests/specs
      --   alt-x: e(x)clude (all except tests/specs)
      --   alt-s: scripts (js/ts)
      --   alt-m: exclude bundle modules (umd/cjs/esm)
      --   alt-c: conf type
      --   alt-w: web type
      ------------------------------------------------
      --   alt-g: glob case-insensitive
      --   alt-k: context (2 lines)
      --   alt-n: max count (1 per file)
      --   alt-d: max depth (3)
      --   alt-p: pcre2
      --   alt-u: unrestricted (rg -U)
      --   alt-l: lua type
      --   alt-r: ruby type
      --   alt-f: filepath sort
      --   alt-y: toggle treesitter s(y)ntax highlighting
      --   alt-z: toggle path truncation (cycles: off -> 60 -> 40 -> 80)

      local mappings = {
        add_glob = { char = "<C-o>", func = add_glob },
        remove_glob = { char = "<C-k>", func = remove_glob },
        toggle_no_ignore = { char = "<M-i>", func = toggle_no_ignore },
        toggle_hidden = { char = "<M-h>", func = toggle_hidden },
        -- Iglob pattern toggles
        toggle_js_no_tests = { char = "<M-j>", func = toggle_iglob_pattern("js_no_tests") },
        toggle_js_tests = { char = "<M-o>", func = toggle_iglob_pattern("js_tests") },
        toggle_tests = { char = "<M-t>", func = toggle_iglob_pattern("tests") },
        toggle_no_tests = { char = "<M-x>", func = toggle_iglob_pattern("no_tests") },
        toggle_js_ts = { char = "<M-s>", func = toggle_iglob_pattern("js_ts") },
        toggle_no_bundle = { char = "<M-m>", func = toggle_iglob_pattern("no_bundle") },
        -- Extra flag toggles
        toggle_type_conf = { char = "<M-c>", func = toggle_extra_flag("type_conf") },
        toggle_type_web = { char = "<M-w>", func = toggle_extra_flag("type_web") },
        toggle_glob_case = { char = "<M-g>", func = toggle_extra_flag("glob_case_insensitive") },
        toggle_context = { char = "<M-k>", func = toggle_extra_flag("context") },
        toggle_max_count = { char = "<M-n>", func = toggle_extra_flag("max_count") },
        toggle_max_depth = { char = "<M-d>", func = toggle_extra_flag("max_depth") },
        toggle_pcre2 = { char = "<M-p>", func = toggle_extra_flag("pcre2") },
        toggle_dotall = { char = "<M-u>", func = toggle_dotall },
        toggle_type_lua = { char = "<M-l>", func = toggle_extra_flag("type_lua") },
        toggle_type_ruby = { char = "<M-r>", func = toggle_extra_flag("type_ruby") },
        toggle_sort_path = { char = "<M-f>", func = toggle_extra_flag("sort_path") },
        toggle_ts_highlight = { char = "<M-y>", func = toggle_ts_highlight },
        toggle_path_width = { char = "<M-z>", func = toggle_path_width },
      }

      opts = vim.tbl_deep_extend("force", opts or {}, { source = { items = {}, match = match }, mappings = mappings })
      return MiniPick.start(opts)
    end
    return igrep_live(local_opts, opts)
  end
end

M.setup = function(MiniPick)
  MiniPick.registry.iglob_ts = create_iglob_picker(MiniPick)
end

return M
